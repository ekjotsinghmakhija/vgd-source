name: Build VGD macOS DMG

# Release workflow:
# 1. Create a draft GitHub Release with the tag name (e.g. v1.0.0) and write release notes.
# 2. Push the tag: git tag v1.0.0 && git push origin v1.0.0
# 3. This workflow builds, signs, and notarizes the DMG.
# 4. The DMG is uploaded directly to the GitHub Release.

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"
    branches:
      - "test-app"

jobs:
  build-macos-app:
    runs-on: "macos-14" # Using standard Apple Silicon runner
    permissions:
      contents: write
    env:
      # S3 and AWS variables removed
      SPARKLE_VERSION: 2.9.0-beta.1
      SPARKLE_FEED_URL: ${{ secrets.SPARKLE_FEED_URL }}
      SPARKLE_ED25519_PUBLIC: ${{ secrets.SPARKLE_ED25519_PUBLIC }}
      SPARKLE_ED25519_PRIVATE: ${{ secrets.SPARKLE_ED25519_PRIVATE }}
      VGD_BUG_REPORT_PRESIGNED_URL_ENDPOINT: ${{ secrets.VGD_BUG_REPORT_PRESIGNED_URL_ENDPOINT }}
      VGD_BUILD_NUMBER: ${{ github.run_number }}
      VGD_LIBP2P_NAMESPACE: ${{ github.ref_name }}

    steps:
      # ============================================================
      # Checkout and tag validation
      # ============================================================

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Derive release version from tag
        run: |
          if [[ "$GITHUB_REF_NAME" == "test-app" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="0.0.0-alpha.0"
            echo "IS_ALPHA=true" >> $GITHUB_ENV
          else
            VERSION="${GITHUB_REF_NAME#v}"
            if [[ "$VERSION" == *-alpha* ]]; then
              echo "IS_ALPHA=true" >> $GITHUB_ENV
            else
              echo "IS_ALPHA=false" >> $GITHUB_ENV
            fi
          fi
          echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Compute build version from semver
        run: |
          VERSION="$RELEASE_VERSION"
          BASE_VERSION="${VERSION%%-*}"
          MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
          MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
          PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)

          if [[ "$VERSION" == *-* ]]; then
            PRERELEASE_PART="${VERSION#*-}"
            PRERELEASE_NUM="${PRERELEASE_PART##*.}"
            if ! [[ "$PRERELEASE_NUM" =~ ^[0-9]+$ ]]; then PRERELEASE_NUM=0; fi
          else
            PRERELEASE_NUM=999
          fi

          BUILD_VERSION=$((PRERELEASE_NUM + 1000 * PATCH + 1000000 * MINOR + 1000000000 * MAJOR))
          echo "VGD_BUILD_VERSION=$BUILD_VERSION" >> $GITHUB_ENV

      - name: Ensure tag commit is on main
        if: github.ref_type == 'tag'
        run: |
          git fetch origin main
          if [[ "$IS_ALPHA" == "true" ]]; then
            echo "Alpha tag detected, skipping main branch check"
          elif ! git merge-base --is-ancestor origin/main HEAD; then
            echo "Production tag must point to a commit on main"
            exit 1
          fi

      - name: Fetch and validate release notes
        if: github.ref_type == 'tag'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Looking for draft release named '$GITHUB_REF_NAME'..."
          # Fix: Handle multiple drafts by taking the head
          DRAFT_EXISTS=$(gh release list --json name,isDraft --jq ".[] | select(.isDraft == true) | select(.name == \"$GITHUB_REF_NAME\") | .name" 2>/dev/null | head -n 1 || echo "")

          if [[ -z "$DRAFT_EXISTS" ]]; then
            if [[ "$IS_ALPHA" == "true" ]]; then
              echo "HAS_RELEASE_NOTES=false" >> $GITHUB_ENV
              exit 0
            fi
            echo "ERROR: No draft release found for tag $GITHUB_REF_NAME"
            echo "Please create a draft release on GitHub UI with release notes before pushing the tag."
            exit 1
          fi

          echo "Found draft release, fetching details..."
          # Fix: Use 'first' to prevent multiple objects returning
          RELEASE_JSON=$(gh api repos/${{ github.repository }}/releases --jq "[.[] | select(.draft == true) | select(.name == \"$GITHUB_REF_NAME\")] | first" 2>/dev/null || echo "")

          NOTES=$(echo "$RELEASE_JSON" | jq -r '.body // ""')
          if [[ -z "$NOTES" || "$NOTES" == "null" ]]; then
            echo "ERROR: Draft release exists but has no release notes"
            exit 1
          fi

          RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r '.id')
          # Fix: Clean ID to remove whitespace/newlines
          RELEASE_ID=$(echo "$RELEASE_ID" | tr -d '[:space:]')

          echo "DRAFT_RELEASE_ID=$RELEASE_ID" >> $GITHUB_ENV
          echo "HAS_RELEASE_NOTES=true" >> $GITHUB_ENV

          echo "$NOTES" > /tmp/release_notes.md
          echo "RELEASE_NOTES_FILE=/tmp/release_notes.md" >> $GITHUB_ENV

      # ============================================================
      # Install dependencies
      # ============================================================

      - name: Select Xcode 15+
        run: |
          sudo xcode-select -s /Applications/Xcode_15.4.app || sudo xcode-select -r

      - name: Install Homebrew packages
        run: brew install just awscli macmon

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true

      - name: Setup Python
        run: |
          uv python install
          uv sync --locked

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Build dashboard
        run: |
          DASHBOARD_OUT=$(nix build .#dashboard --print-build-logs --no-link --print-out-paths)
          mkdir -p dashboard/build
          cp -r "$DASHBOARD_OUT"/* dashboard/build/

      - name: Install Sparkle CLI
        run: |
          CLI_URL="${SPARKLE_CLI_URL:-https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz}"
          mkdir -p /tmp/sparkle
          curl --fail --location --output /tmp/sparkle.tar.xz "$CLI_URL"
          tar -xJf /tmp/sparkle.tar.xz -C /tmp/sparkle --strip-components=1
          echo "SPARKLE_BIN=/tmp/sparkle/bin" >> $GITHUB_ENV

      - name: Prepare code-signing keychain
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          PROVISIONING_PROFILE: ${{ secrets.PROVISIONING_PROFILE }}
        run: |
          KEYCHAIN_PATH="$HOME/Library/Keychains/build.keychain-db"
          security create-keychain -p "$MACOS_CERTIFICATE_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$MACOS_CERTIFICATE_PASSWORD" "$KEYCHAIN_PATH"
          echo "$MACOS_CERTIFICATE" | base64 --decode > /tmp/cert.p12
          security import /tmp/cert.p12 -k "$KEYCHAIN_PATH" -P "$MACOS_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productbuild
          rm /tmp/cert.p12
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CERTIFICATE_PASSWORD" "$KEYCHAIN_PATH"
          mkdir -p "$HOME/Library/Developer/Xcode/UserData/Provisioning Profiles"
          echo "$PROVISIONING_PROFILE" | base64 --decode > "$HOME/Library/Developer/Xcode/UserData/Provisioning Profiles/VGD.provisionprofile"
          echo "BUILD_KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

      # ============================================================
      # Build the bundle
      # ============================================================

      - name: Build PyInstaller bundle
        run: uv run pyinstaller packaging/pyinstaller/vgd.spec

      - name: Build Swift app
        env:
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          SPARKLE_FEED_URL: ${{ secrets.SPARKLE_FEED_URL }}
          SPARKLE_ED25519_PUBLIC: ${{ secrets.SPARKLE_ED25519_PUBLIC }}
        run: |
          cd app/VGD
          security unlock-keychain -p "$MACOS_CERTIFICATE_PASSWORD" "$BUILD_KEYCHAIN_PATH"
          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$BUILD_KEYCHAIN_PATH" | awk -F '"' '{print $2}')
          xcodebuild clean build \
            -scheme VGD \
            -configuration Release \
            -derivedDataPath build \
            MARKETING_VERSION="$RELEASE_VERSION" \
            CURRENT_PROJECT_VERSION="$VGD_BUILD_VERSION" \
            VGD_BUILD_TAG="$RELEASE_VERSION" \
            VGD_BUILD_COMMIT="$GITHUB_SHA" \
            SPARKLE_FEED_URL="$SPARKLE_FEED_URL" \
            SPARKLE_ED25519_PUBLIC="$SPARKLE_ED25519_PUBLIC" \
            VGD_BUG_REPORT_PRESIGNED_URL_ENDPOINT="$VGD_BUG_REPORT_PRESIGNED_URL_ENDPOINT" \
            CODE_SIGNING_IDENTITY="$SIGNING_IDENTITY" \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=YES
          mkdir -p ../../output
          cp -R build/Build/Products/Release/VGD.app ../../output/VGD.app

      - name: Inject PyInstaller runtime
        run: |
          rm -rf output/VGD.app/Contents/Resources/vgd
          mkdir -p output/VGD.app/Contents/Resources
          cp -R dist/vgd output/VGD.app/Contents/Resources/vgd

      - name: Codesign PyInstaller runtime
        env:
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          cd output
          security unlock-keychain -p "$MACOS_CERTIFICATE_PASSWORD" "$BUILD_KEYCHAIN_PATH"
          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$BUILD_KEYCHAIN_PATH" | awk -F '"' '{print $2}')
          RUNTIME_DIR="VGD.app/Contents/Resources/vgd"
          find "$RUNTIME_DIR" -type f \( -perm -111 -o -name "*.dylib" -o -name "*.so" \) -print0 |
            while IFS= read -r -d '' file; do
              /usr/bin/codesign --force --timestamp --options runtime \
                --sign "$SIGNING_IDENTITY" "$file"
            done

      - name: Sign, notarize, and create DMG
        env:
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          APPLE_NOTARIZATION_USERNAME: ${{ secrets.APPLE_NOTARIZATION_USERNAME }}
          APPLE_NOTARIZATION_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}
          APPLE_NOTARIZATION_TEAM: ${{ secrets.APPLE_NOTARIZATION_TEAM }}
        run: |
          cd output
          security unlock-keychain -p "$MACOS_CERTIFICATE_PASSWORD" "$BUILD_KEYCHAIN_PATH"
          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$BUILD_KEYCHAIN_PATH" | awk -F '"' '{print $2}')
          /usr/bin/codesign --deep --force --timestamp --options runtime \
            --sign "$SIGNING_IDENTITY" VGD.app
          mkdir -p dmg-root
          cp -R VGD.app dmg-root/
          ln -s /Applications dmg-root/Applications
          DMG_NAME="VGD-${RELEASE_VERSION}.dmg"
          hdiutil create -volname "VGD" -srcfolder dmg-root -ov -format UDZO "$DMG_NAME"
          /usr/bin/codesign --force --timestamp --options runtime \
            --sign "$SIGNING_IDENTITY" "$DMG_NAME"

          if [[ -n "$APPLE_NOTARIZATION_USERNAME" ]]; then
            SUBMISSION_OUTPUT=$(xcrun notarytool submit "$DMG_NAME" \
              --apple-id "$APPLE_NOTARIZATION_USERNAME" \
              --password "$APPLE_NOTARIZATION_PASSWORD" \
              --team-id "$APPLE_NOTARIZATION_TEAM" \
              --wait --timeout 15m 2>&1)
            echo "$SUBMISSION_OUTPUT"
            SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | awk 'tolower($1)=="id:" && $2 ~ /^[0-9a-fA-F-]+$/ {print $2; exit}')
            STATUS=$(echo "$SUBMISSION_OUTPUT" | awk 'tolower($1)=="status:" {print $2; exit}')
            if [[ "$STATUS" != "Accepted" ]]; then
              exit 1
            fi
            xcrun stapler staple "$DMG_NAME"
          fi

      - name: Generate Sparkle appcast
        env:
          SPARKLE_ED25519_PRIVATE: ${{ secrets.SPARKLE_ED25519_PRIVATE }}
          IS_ALPHA: ${{ env.IS_ALPHA }}
        run: |
          set -euo pipefail
          cd output
          DOWNLOAD_PREFIX="https://github.com/${{ github.repository }}/releases/download/$GITHUB_REF_NAME"
          echo "$SPARKLE_ED25519_PRIVATE" > sparkle_ed25519.key
          chmod 600 sparkle_ed25519.key
          CHANNEL_FLAG=""
          if [[ "$IS_ALPHA" == "true" ]]; then CHANNEL_FLAG="--channel alpha"; fi

          $SPARKLE_BIN/generate_appcast \
            --ed-key-file sparkle_ed25519.key \
            --download-url-prefix "$DOWNLOAD_PREFIX" \
            $CHANNEL_FLAG \
            .

      # ============================================================
      # Upload artifacts
      # ============================================================

      - name: Upload DMG to Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: VGD-dmg-${{ env.RELEASE_VERSION }}
          path: output/VGD-${{ env.RELEASE_VERSION }}.dmg

      - name: Publish GitHub Release
        if: github.ref_type == 'tag'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DMG_PATH="output/VGD-${RELEASE_VERSION}.dmg"
          APPCAST_PATH="output/appcast.xml"

          if [[ "$HAS_RELEASE_NOTES" == "true" ]]; then
            # Update the draft release: publish it and attach assets
            gh api --method PATCH "repos/${{ github.repository }}/releases/$DRAFT_RELEASE_ID" \
              -f tag_name="$GITHUB_REF_NAME" \
              -F draft=false

            gh release upload "$GITHUB_REF_NAME" "$DMG_PATH" --clobber
            gh release upload "$GITHUB_REF_NAME" "$APPCAST_PATH" --clobber

            echo "✅ Published release $GITHUB_REF_NAME with DMG attached"
          else
            # Fallback for alpha releases without drafts
            gh release create "$GITHUB_REF_NAME" "$DMG_PATH" "$APPCAST_PATH" \
              --title "$GITHUB_REF_NAME" \
              --generate-notes \
              --prerelease
            echo "✅ Created alpha release $GITHUB_REF_NAME"
          fi
